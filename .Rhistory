cols = unit(3.8, "in"))
? scale_color_gradientn
ggplot(knot) + geom_point(aes(x=x, y=y, colour = (rowMeans(theta_sim)-rowMeans(Theta))/rowMeans(theta_sim)/10), size=6) +
scale_x_continuous(expand=c(0,0), limits = c(0,10)) + scale_color_gradientn(limit = c(-0.045,0.045), colors = pal, name=expression(gamma[k])) +
scale_y_continuous(expand=c(0,0), limits = c(0,10)) +
theme(axis.text.y=element_blank(),
axis.ticks.y=element_blank(),
axis.title.y = element_blank(),
plot.title = element_text(hjust = 0.5, face="bold"))+
force_panelsizes(rows = unit(3.5, "in"),
cols = unit(3.8, "in"))
range((rowMeans(theta_sim)-rowMeans(Theta))/rowMeans(theta_sim)/10)
ggplot(knot) + geom_point(aes(x=x, y=y, colour = (rowMeans(theta_sim)-rowMeans(Theta))/rowMeans(theta_sim)/10), size=6) +
scale_x_continuous(expand=c(0,0), limits = c(0,10)) + scale_color_gradientn(limit = c(-0.049,0.049), colors = pal, name=expression(gamma[k])) +
scale_y_continuous(expand=c(0,0), limits = c(0,10)) +
theme(axis.text.y=element_blank(),
axis.ticks.y=element_blank(),
axis.title.y = element_blank(),
plot.title = element_text(hjust = 0.5, face="bold"))+
force_panelsizes(rows = unit(3.5, "in"),
cols = unit(3.8, "in"))
pdf(file="../Figures/theta_s_sim.pdf", width=4, height = 4)
pal <- RColorBrewer::brewer.pal(9, "RdBu")
ggplot(knot) + geom_point(aes(x=x, y=y, colour = (rowMeans(theta_sim)-rowMeans(Theta))/rowMeans(theta_sim)/10), size=6) +
scale_x_continuous(expand=c(0,0), limits = c(0,10)) + scale_color_gradientn(limit = c(-0.049,0.049), colors = pal, name=expression(gamma[k])) +
scale_y_continuous(expand=c(0,0), limits = c(0,10)) +
theme(axis.text.y=element_blank(),
axis.ticks.y=element_blank(),
axis.title.y = element_blank(),
plot.title = element_text(hjust = 0.5, face="bold"))+
force_panelsizes(rows = unit(3.5, "in"),
cols = unit(3.8, "in"))
dev.off()
pdf(file="../Figures/theta_t_sim.pdf", width=4, height = 4)
plot(colMeans(Theta), xlab=expression(paste("time ", italic(t))), type='l')
lines(colMeans(theta_sim), col=scales::alpha('#0840a8',0.5), lwd=2)
lines(fit$fitted.values, col = '#f04207', lwd=1.5)
grid()
dev.off()
pdf(file="../Figures/theta_s_sim.pdf", width=6, height = 4)
pal <- RColorBrewer::brewer.pal(9, "RdBu")
ggplot(knot) + geom_point(aes(x=x, y=y, colour = (rowMeans(theta_sim)-rowMeans(Theta))/rowMeans(theta_sim)/10), size=6) +
scale_x_continuous(expand=c(0,0), limits = c(0,10)) + scale_color_gradientn(limit = c(-0.049,0.049), colors = pal, name=expression(gamma[k])) +
scale_y_continuous(expand=c(0,0), limits = c(0,10)) +
theme(axis.text.y=element_blank(),
axis.ticks.y=element_blank(),
axis.title.y = element_blank(),
plot.title = element_text(hjust = 0.5, face="bold"))+
force_panelsizes(rows = unit(3.5, "in"),
cols = unit(3.8, "in"))
dev.off()
pdf(file="../Figures/theta_s_sim.pdf", width=6, height = 4)
pal <- RColorBrewer::brewer.pal(9, "RdBu")
ggplot(knot) + geom_point(aes(x=x, y=y, colour = (rowMeans(theta_sim)-rowMeans(Theta))/rowMeans(theta_sim)/10), size=6) +
scale_x_continuous(expand=c(0,0), limits = c(0,10)) + scale_color_gradientn(limit = c(-0.049,0.049), colors = pal, name=expression(gamma[k])) +
scale_y_continuous(expand=c(0,0), limits = c(0,10)) +
theme(
plot.title = element_text(hjust = 0.5, face="bold"))+
force_panelsizes(rows = unit(3.5, "in"),
cols = unit(3.8, "in"))
dev.off()
ggplot(knot) + geom_point(aes(x=x, y=y, colour = (rowMeans(theta_sim)-rowMeans(Theta))/rowMeans(theta_sim)/10), size=6) +
scale_x_continuous(expand=c(0,0), limits = c(0,10)) + scale_color_gradientn(limit = c(-0.049,0.049), colors = pal) +
scale_y_continuous(expand=c(0,0), limits = c(0,10)) +
theme(
plot.title = element_text(hjust = 0.5, face="bold"))+
force_panelsizes(rows = unit(3.5, "in"),
cols = unit(3.8, "in"))
ggplot(knot) + geom_point(aes(x=x, y=y, colour = (rowMeans(theta_sim)-rowMeans(Theta))/rowMeans(theta_sim)/10), size=6) +
scale_x_continuous(expand=c(0,0), limits = c(0,10)) + scale_color_gradientn(limit = c(-0.049,0.049), colors = pal, name=expression(gamma[k])) +
scale_y_continuous(expand=c(0,0), limits = c(0,10)) +
theme(
plot.title = element_text(hjust = 0.5, face="bold"))+
force_panelsizes(rows = unit(3.5, "in"),
cols = unit(3.8, "in"))
pdf(file="../Figures/theta_s_sim.pdf", width=5.5, height = 5)
pal <- RColorBrewer::brewer.pal(9, "RdBu")
ggplot(knot) + geom_point(aes(x=x, y=y, colour = (rowMeans(theta_sim)-rowMeans(Theta))/rowMeans(theta_sim)/10), size=6) +
scale_x_continuous(expand=c(0,0), limits = c(0,10)) + scale_color_gradientn(limit = c(-0.049,0.049), colors = pal, name=expression(gamma[k])) +
scale_y_continuous(expand=c(0,0), limits = c(0,10)) +
theme(
plot.title = element_text(hjust = 0.5, face="bold"))+
force_panelsizes(rows = unit(3.5, "in"),
cols = unit(3.8, "in"))
dev.off()
plot(colMeans(Theta), xlab=expression(paste("time ", italic(t))), type='l')
lines(colMeans(theta_sim), col=scales::alpha('#0840a8',0.5), lwd=2)
lines(fit$fitted.values, col = '#f04207', lwd=1.5)
68+42+65.98+114.10
source("utils.R")
###### ---------------------------------------------------------------------- ######
###### ---------------------------- Simulation ------------------------------ ######
###### ---------------------------------------------------------------------- ######
set.seed(123)
stations <- data.frame(x=runif(2000, 0, 10), y=runif(2000, 0, 10))
knot <- expand.grid(x=c(1,3,5,7,9),y=c(1,3,5,7,9))
# plot(stations)
# points(knot, pch="+", col='red', cex=2)
k = nrow(knot)
n.s <- nrow(stations)
n.t <- 100 # n.t <- 500
eucD <- rdist(stations,as.matrix(knot))
W <- wendland(eucD,r=3)
W <- sweep(W, 1, rowSums(W), FUN="/")
theta_sim <- (sin(knot$x/2)*cos(knot$y/2)+1)/50
theta_sim[theta_sim < 0.005] <- 0
theta_sim <- matrix(rep(theta_sim, n.t), ncol=n.t)
# fields::image.plot(c(1,3,5,7,9), c(1,3,5,7,9), matrix(theta_sim[,1],5,5), col=terrain.colors(25))
# Setting up the Fréchet white noise process
alpha = 0.5; tau <- 0.1; m <- 0.85
Z <- matrix(NA, nrow=k, ncol=n.t)
X <- matrix(NA, nrow=n.s, ncol=n.t)
Epsilon_frechet <- matrix(NA, nrow=n.s, ncol=n.t)
set.seed(12)
for (iter in 1:n.t) {
for (i in 1:k) {
Z[i,iter] <- single_rejection_sampler(theta = theta_sim[i,iter])
}
Epsilon_frechet[,iter] <-  VGAM::rfrechet(n.s, shape=1, scale = tau, location = m)
X[,iter] <-  Epsilon_frechet[,iter]* ((W^(1/alpha))%*%Z[,iter])
}
ind=1
spatial_map(stations, var=X[,ind], tight.brks = TRUE, title=paste0('Time replicate #', ind), raster = FALSE)
load("example_X.RData")
eucD <- rdist(stations,as.matrix(knots))
as.matrix(knots)
knots
Then, we apply Algorithm 1 in the Supplementary Material of Zhang et al. [[2]](#2) to select a collection of data-driven knots:
knots <- data_driven_knots(X, stations, threshold_p, echo=TRUE)
#' 2. A clustering algorithm (`k-means`) is applied to the spatial locations of these high values
#'    to identify clusters, with the number of clusters determined dynamically based on the WSS.
#' 3. The center within each cluster is chosen as a knot.
#' 4. Additional coarse grid knots are generated, and all knot candidates are refined to ensure
#'    adequate spacing by eliminating close points.
#'
#' @examples
#' # Load example data
#' load("example_X.RData")
#' knots <- data_driven_knots(X, stations, threshold_p = 0.96)
data_driven_knots <- function(X, stations, threshold_p, echo=FALSE, start.knot.num = NULL){
# Set the default number of knots if not specified
if (is.null(start.knot.num))
start.knot.num <- round(5 * log(nrow(stations)))
# Define the threshold based on the quantile of X
threshold <- quantile(X, probs = threshold_p)
data.knots <- data.frame(x = NA, y = NA)
# Loop through each time replicate
for (iter.t in 1:ncol(X)) {
# Identify sites exceeding the threshold
where.exceed <- which(X[, iter.t] > threshold)
# Only proceed if there are enough exceedances
if (length(where.exceed) > 10) {
# Determine the range of cluster counts to test
tmp.min <- min(15, length(where.exceed) - 1)
k.values <- 1:tmp.min
tmp_df <- stations[where.exceed, ]
tmp.obs <- X[where.exceed, iter.t]
# Compute WSS for potential cluster counts
wss_values <- unlist(lapply(k.values, wss, df = tmp_df))
# Identify the optimal number of clusters
n.clusters <- which(wss_values / wss_values[1] < 0.15)[1]
# Perform k-means clustering with the optimal number of clusters
res <- kmeans(tmp_df, n.clusters, nstart = 10)
# Select the point with the highest value within each cluster as a knot
for (tmp.iter in 1:n.clusters) {
where.max <- which.max(tmp.obs[res$cluster == tmp.iter])
data.knots <- rbind(data.knots, tmp_df[where.max, ])
}
}
}
# Remove the placeholder first row
data.knots <- data.knots[-1, ]
# Refine knots by clustering them again
res <- kmeans(data.knots, start.knot.num, nstart = 10)
# Generate additional coarse grid knot candidates
coarse.grid.length <- round(sqrt(start.knot.num))
knot_candidates <- as.matrix(expand.grid(
x = seq(min(stations[, 1]), max(stations[, 1]), length.out = coarse.grid.length),
y = seq(min(stations[, 2]), max(stations[, 2]), length.out = coarse.grid.length)
))
# Combine cluster centers and coarse grid knots
knots <- rbind(knot_candidates, res$centers)
rownames(knots) <- NULL
# Calculate pairwise distances and eliminate close knots
distances <- fields::rdist(knots)
min.gap <- max(distances) / 30
where.close <- which(distances < min.gap & distances > 0, arr.ind = TRUE)
eliminate <- c()
if (nrow(where.close) > 0) {
for (tmp.iter in 1:nrow(where.close)) {
tmp_row <- where.close[tmp.iter, ]
if (tmp_row[1] > tmp_row[2]) eliminate <- c(eliminate, tmp_row[2])
}
}
# Remove eliminated knots
if (length(eliminate) > 0)
knots <- knots[-eliminate, ]
if(echo){
plot(data.knots, pch=20, col=res$cluster)
points(knots, pch='+', col='red')
}
return(knots)
}
knots <- data_driven_knots(X, stations, threshold_p, echo=TRUE)
knots <- data_driven_knots(X, stations, 0.95, echo=TRUE)
wss <- function(k, df) {
kmeans(df, k, nstart = 10)$tot.withinss
}
knots <- data_driven_knots(X, stations, 0.95, echo=TRUE)
eucD <- rdist(stations,as.matrix(knots))
eucD
dim(eucD)
apply(eucD, 1, min)
hist(apply(eucD, 1, min))
2*max(nearest_knot_dist)  #making sure every location gets covered by one knot
nearest_knot_dist <- apply(eucD, 1, min)
2*max(nearest_knot_dist)  #making sure every location gets covered by one knot
Then, we apply Algorithm 1 in the Supplementary Material of Zhang et al. [[2]](#2) to select data-driven knots based on high values (e.g., `thresh_p=0.95`) in the input data matrix and also determine the radius for the Wendland basis functions:
r <- calc_radius(knots, stations)
# Function to calculate the radius needed to ensure all locations are covered by at least one knot
# Inputs:
#   knots: A matrix or dataframe of knot coordinates
#   stations: A matrix or dataframe of station coordinates
# Output:
#   radius: The automatically-determined radius such that any station is covered by at least one basis function
calc_radius <- function(knots, stations) {
# Compute the Euclidean distance between each station and all knots
eucD <- rdist(stations, as.matrix(knots))
# Find the minimum distance from each station to the nearest knot
nearest_knot_dist <- apply(eucD, 1, min) # Find the minimum distance for each station
#  Determine the radius, ensuring all stations are covered by one or more knots
radius <- 2 * max(nearest_knot_dist)
return(radius)
}
r <- calc_radius(knots, stations)
r
W <- wendland(eucD,r=r)
W <- sweep(W, 1, rowSums(W), FUN="/")
dim(W)
W
dim(W)
k = nrow(knots)
n.s <- nrow(stations)
n.t <- ncol(X)
n.t
library(ggplot2)
ggplot(knots) + geom_point(aes(x=x, y=y), shape='+', size=6, color='red') +
geom_path(data=dat, aes(x=x, y=y, group=group)) +
geom_point(data=stations[which(W[,1]>0.001),], aes(x = x, y = y), colour=scales::alpha("blue", 0.1))+
geom_point(data=stations[which(W[,10]>0.1),], aes(x = x, y = y), colour=scales::alpha("green", 0.1))+
geom_point(data=stations[which(W[,12]>0.001),], aes(x = x, y = y), colour=scales::alpha("yellow", 0.1))+
geom_point(data=stations[which(apply(W,1,function(x) any(is.na(x)))),], aes(x = x, y = y), colour="black")
ggplot(knots) + geom_point(aes(x=x, y=y), shape='+', size=6, color='red')
knots
stations <- data.frame(stations)
knots <- data.frame(knots)
library(ggplot2)
ggplot(knots) + geom_point(aes(x=x, y=y), shape='+', size=6, color='red')
library(ggplot2)
ggplot(knots) + geom_point(aes(x=x, y=y), shape='+', size=6, color='red') +
geom_path(data=dat, aes(x=x, y=y, group=group)) +
geom_point(data=stations[which(W[,1]>0.001),], aes(x = x, y = y), colour=scales::alpha("blue", 0.1))+
geom_point(data=stations[which(W[,10]>0.1),], aes(x = x, y = y), colour=scales::alpha("green", 0.1))+
geom_point(data=stations[which(W[,12]>0.001),], aes(x = x, y = y), colour=scales::alpha("yellow", 0.1))+
geom_point(data=stations[which(apply(W,1,function(x) any(is.na(x)))),], aes(x = x, y = y), colour="black")
ggplot(knots) + geom_point(aes(x=x, y=y), shape='+', size=6, color='red') +
#geom_path(data=dat, aes(x=x, y=y, group=group)) +
geom_point(data=stations[which(W[,1]>0.001),], aes(x = x, y = y), colour=scales::alpha("blue", 0.1))+
geom_point(data=stations[which(W[,10]>0.1),], aes(x = x, y = y), colour=scales::alpha("green", 0.1))+
geom_point(data=stations[which(W[,12]>0.001),], aes(x = x, y = y), colour=scales::alpha("yellow", 0.1))+
geom_point(data=stations[which(apply(W,1,function(x) any(is.na(x)))),], aes(x = x, y = y), colour="black")
knots
colnames(knots)
colnames(knots) <- c('x', 'y')
visualize_knots <- function(knots, stations, r, W, select = c(1, 12, 10)) {
# Step 1: Generate circular paths for each knot's coverage
# Create the first circle based on the first knot
dat <- cbind(circleFun(unlist(knots[1, ]), diameter = r * 2, npoints = 100), group = 1)
colnames(knots) <- c('x', 'y')
# Add circles for the remaining knots
for (iter in 2:nrow(knots)) {
dat <- rbind(dat, cbind(circleFun(unlist(knots[iter, ]), diameter = r * 2, npoints = 100), group = iter))
}
# Step 2: Load ggplot2 library for visualization
library(ggplot2)
# Step 3: Create the plot
fig <- ggplot(knots) +
# Plot knots as red '+' symbols
geom_point(aes(x = x, y = y), shape = '+', size = 6, color = 'red') +
# Plot circular coverage regions
geom_path(data = dat, aes(x = x, y = y, group = group)) +
# Plot stations influenced by the first selected knot in blue
geom_point(
data = stations[which(W[, select[1]] > 0.001), ],
aes(x = x, y = y),
colour = scales::alpha("blue", 0.1)
) +
# Plot stations influenced by the second selected knot in green
geom_point(
data = stations[which(W[, select[2]] > 0.1), ],
aes(x = x, y = y),
colour = scales::alpha("green", 0.1)
) +
# Plot stations influenced by the third selected knot in yellow
geom_point(
data = stations[which(W[, select[3]] > 0.001), ],
aes(x = x, y = y),
colour = scales::alpha("yellow", 0.1)
) +
# Plot stations with missing data (NA weights) in black
geom_point(
data = stations[which(apply(W, 1, function(x) any(is.na(x)))), ],
aes(x = x, y = y),
colour = "black"
)
# Step 4: Return the ggplot object
fig
}
``` ruby
visualize_knots(knots, stations, r, W)
visualize_knots <- function(knots, stations, r, W, select = c(1, 12, 10)) {
# Step 1: Generate circular paths for each knot's coverage
# Create the first circle based on the first knot
dat <- cbind(circleFun(unlist(knots[1, ]), diameter = r * 2, npoints = 100), group = 1)
colnames(knots) <- c('x', 'y')
# Add circles for the remaining knots
for (iter in 2:nrow(knots)) {
dat <- rbind(dat, cbind(circleFun(unlist(knots[iter, ]), diameter = r * 2, npoints = 100), group = iter))
}
# Step 2: Load ggplot2 library for visualization
library(ggplot2)
# Step 3: Create the plot
fig <- ggplot(knots) +
# Plot knots as red '+' symbols
geom_point(aes(x = x, y = y), shape = '+', size = 6, color = 'red') +
# Plot circular coverage regions
geom_path(data = dat, aes(x = x, y = y, group = group)) +
# Plot stations influenced by the first selected knot in blue
geom_point(
data = stations[which(W[, select[1]] > 0.001), ],
aes(x = x, y = y),
colour = scales::alpha("blue", 0.3)
) +
# Plot stations influenced by the second selected knot in green
geom_point(
data = stations[which(W[, select[2]] > 0.001), ],
aes(x = x, y = y),
colour = scales::alpha("green", 0.3)
) +
# Plot stations influenced by the third selected knot in yellow
geom_point(
data = stations[which(W[, select[3]] > 0.001), ],
aes(x = x, y = y),
colour = scales::alpha("yellow", 0.3)
) +
# Plot stations with no coverage (NA weights) in black
geom_point(
data = stations[which(apply(W, 1, function(x) any(is.na(x)))), ],
aes(x = x, y = y),
colour = "black"
)
# Step 4: Return the ggplot object
fig
}
visualize_knots(knots, stations, r, W)
?qr.solve
#### 2. Initial values for latent variables
In this section, we first find the initial values for the latent expPS variables via solving a linear system using QR decomposition:
W_alpha <- W^(1/alpha)
Z_approx <- array(NA, dim=c(k, n.t))
for (iter in 1:n.t){
cat('Finding good initial Z_t for time', iter, '\n')
Z_approx[,iter] <- relu(qr.solve(a=W_alpha, b=X[,iter]))
}
W_alpha <- W^(1/alpha)
Z_approx <- array(NA, dim=c(k, n.t))
for (iter in 1:n.t){
if(iter %% 10 == 0 ) cat('Finding good initial Z_t for time', iter, '\n')
Z_approx[,iter] <- relu(qr.solve(a=W_alpha, b=X[,iter]))
}
Y/Y_star
(W^(1/alpha))%*%Z/Y_star
(W^(1/alpha))%*%Z
Z
dim((W^(1/alpha))
)
dim(Z)
hist(X/Y_star)
Y_star <- (W_alpha)%*%(Z_approx)
Y_approx <- Y_star - relu(Y_star-X)
hist(X/Y_star)
range(X/Y_star)
ind <- 3
tmp_range <- range(c(log(Y_approx[,ind])), log(X[,ind]))
ggplot(stations) + geom_point(aes(x=x, y=y, color=log(X[,ind]))) +
scale_color_gradientn(colours = topo.colors(100), name = paste0('Original replicate #', ind), na.value = NA, limits=tmp_range)
ggplot(stations) + geom_point(aes(x=x, y=y, color=log(Y_approx[,ind]))) +
scale_color_gradientn(colours = topo.colors(100), name = paste0('Smooth replicate #', ind), na.value = NA, limits=tmp_range)
setwd("~/Desktop/GEV-GP_VAE/XVAE")
source("utils.R")
load("example_X.RData")
knots <- data_driven_knots(X, stations, 0.95, echo=TRUE)
r <- calc_radius(knots, stations)
eucD <- rdist(stations,as.matrix(knots))
W <- wendland(eucD,r=r)
W <- sweep(W, 1, rowSums(W), FUN="/")
dim(W)  # Verify dimensions: `n.s` × `k`
k = nrow(knots)
n.s <- nrow(stations)
n.t <- ncol(X)
stations <- data.frame(stations)
knots <- data.frame(knots)
visualize_knots(knots, stations, r, W)
# Setting up the Fréchet white noise process
alpha = 0.5; tau <- 0.1; m <- 0.85
W_alpha <- W^(1/alpha)
Z_approx <- array(NA, dim=c(k, n.t))
for (iter in 1:n.t){
if(iter %% 10 == 0 ) cat('Finding good initial Z_t for time', iter, '\n')
Z_approx[,iter] <- relu(qr.solve(a=W_alpha, b=X[,iter]))
}
# Compute approximations
Y_star <- (W_alpha)%*%(Z_approx)
Y_approx <- Y_star - relu(Y_star-X)
source("Initializing_XVAE.R")
learning_rate <- -1e-15; alpha_v <- 0.9
lrelu <- nn_leaky_relu(-0.01)
nEpoch = 10000
source("XVAE_training_loop.R")
## -------- time 1 --------
ind <- 1
range_t <- c(0, max(X[,ind]))
q25 <- quantile(X[,ind], 0.25)
q75 <- quantile(X[,ind], 0.75)
pal <- RColorBrewer::brewer.pal(9,"PuBu")
plt3 <- spatial_map(stations, var=X[,ind], pal = pal,
title = paste0('Observed copula replicate #', ind), legend.name = "Observed\n values",
brks.round = 1, tight.brks = TRUE, range=range_t, q25=q25, q75=q75, pt.size=0.4, raster=TRUE)
plt3
X[,ind]
range_t
plt3 <- spatial_map(stations, var=X[,ind], pal = pal,
title = paste0('Observed copula replicate #', ind), legend.name = "Observed\n values",
brks.round = 1, tight.brks = TRUE, range=range_t, q25=q25, q75=q75, pt.size=0.4, raster=FALSE)
plt3
pal <- RColorBrewer::brewer.pal(9,"RdBu")
plt3 <- spatial_map(stations, var=X[,ind], pal = pal,
title = paste0('Observed copula replicate #', ind), legend.name = "Observed\n values",
brks.round = 1, tight.brks = TRUE, range=range_t, q25=q25, q75=q75, pt.size=0.4, raster=FALSE)
plt3
plt3 <- spatial_map(stations, var=X[,ind], pal = pal,
title = paste0('Observed copula replicate #', ind), legend.name = "Observed\n values",
brks.round = 1, tight.brks = TRUE, range=range_t, q25=q25, q75=q75, pt.size=1, raster=FALSE)
plt3
Now with the trained XVAE weights and biases in the global environment, we emulate the spatial input using the folowing function:
output <- emulate_from_trained_XVAE()
plt31 <- spatial_map(stations, var=output$emulations[,floor(n.sim/2)], pal = pal,
title = paste0('Emulated copula replicate #', chosen_time), legend.name = "Emulated\n values",
brks.round = 1, tight.brks = TRUE, range=range_t, q25=q25, q75=q75, pt.size=1, raster=FALSE)
plt31 <- spatial_map(stations, var=output$emulations[,chosen_time], pal = pal,
title = paste0('Emulated copula replicate #', chosen_time), legend.name = "Emulated\n values",
brks.round = 1, tight.brks = TRUE, range=range_t, q25=q25, q75=q75, pt.size=1, raster=FALSE)
chosen_time <- 1
range_t <- c(0, max(X[,chosen_time]))
q25 <- quantile(X[,chosen_time], 0.25)
q75 <- quantile(X[,chosen_time], 0.75)
pal <- RColorBrewer::brewer.pal(9,"RdBu")
plt3 <- spatial_map(stations, var=X[,chosen_time], pal = pal,
title = paste0('Observed copula replicate #', chosen_time), legend.name = "Observed\n values",
brks.round = 1, tight.brks = TRUE, range=range_t, q25=q25, q75=q75, pt.size=1, raster=FALSE)
plt3
# ggsave("/Users/LikunZhang/Desktop/img1.png",width = 5.5, height = 5)
plt31 <- spatial_map(stations, var=output$emulations[,chosen_time], pal = pal,
title = paste0('Emulated copula replicate #', chosen_time), legend.name = "Emulated\n values",
brks.round = 1, tight.brks = TRUE, range=range_t, q25=q25, q75=q75, pt.size=1, raster=FALSE)
plt31
chosen_time <- 10
range_t <- c(0, max(X[,chosen_time]))
q25 <- quantile(X[,chosen_time], 0.25)
q75 <- quantile(X[,chosen_time], 0.75)
pal <- RColorBrewer::brewer.pal(9,"RdBu")
plt3 <- spatial_map(stations, var=X[,chosen_time], pal = pal,
title = paste0('Observed copula replicate #', chosen_time), legend.name = "Observed\n values",
brks.round = 1, tight.brks = TRUE, range=range_t, q25=q25, q75=q75, pt.size=1, raster=FALSE)
plt3
# ggsave("/Users/LikunZhang/Desktop/img1.png",width = 5.5, height = 5)
plt31 <- spatial_map(stations, var=output$emulations[,chosen_time], pal = pal,
title = paste0('Emulated copula replicate #', chosen_time), legend.name = "Emulated\n values",
brks.round = 1, tight.brks = TRUE, range=range_t, q25=q25, q75=q75, pt.size=1, raster=FALSE)
plt31
?qqplot
extRemes::qqplot(X[,chosen_time], output$emulations[,chosen_time], regress = FALSE,
xlab=expression(paste('Simulated ', X[t])),
ylab=expression(paste('Emulated ', X[t])), cex.lab = 1.2,
xlim=c(0,19), ylim=c(0,20), main=paste("t =", chosen_time))
q75
quantile(X[,chosen_time], 0.95)
quantile(X[,chosen_time], 0.99)
MSPE <- colMeans((output$emulations - X_holdout)^2)
colMeans((output$emulations - X)^2)
MSPE <- colMeans((output$emulations - X)^2)
boxplot(MSPE,ylim=c(0,500))
116.58*2
?extRemes::qqplot
stations
rdist(stations)
dim(rdist(stations))
center <- which.min(apply(rdist(stations),1,mean))
plot(stations)
points(stations[center,], pch='+', col='red')
?is_regular_grid
install.packages("tidyterra")
