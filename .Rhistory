geom_line(aes(color=names[3]),linewidth=1) +
geom_line(aes(y=truth, color=names[1]),linewidth=1) +
geom_line(aes(y=emu, color=names[2]),linewidth=1) +
scale_color_manual(values=c('#0674cf', 'red', 'black')) +
geom_ribbon(data=dat,aes(ymin=gan_lower,ymax=gan_upper),alpha=0.2,fill="#4190d1") +
geom_ribbon(data=dat,aes(ymin=emu_lower,ymax=emu_upper),alpha=0.2,fill="red") +
geom_ribbon(data=dat,aes(ymin=truth_lower,ymax=truth_upper),alpha=0.2,fill="black") +
labs(colour="Type") +
ylab("Average radius of exceedance (ARE)") + xlab("Quantile") +
theme(plot.title = element_text(hjust = 0.5)) +
scale_x_continuous(expand = c(0, 0)) +
scale_y_continuous(expand = c(0, 0), limits=c(0, 13)) +
force_panelsizes(rows = unit(3.05, "in"),
cols = unit(3.05, "in")) + theme(plot.title = element_text(face = 'bold'))
legend <- TRUE; show.axis.y <- TRUE
if(!legend) plt <- plt + guides(color="none")
if(!show.axis.y) plt<- plt + theme( axis.text.y=element_blank(),
axis.ticks.y=element_blank(),
axis.title.y = element_blank())
plt
}
U_gan_grid <- extGAN_copula; U_xvae_grid <- U_emu_grid; save(U_sim_grid, U_xvae_grid, U_gan_grid, file="./copulas.RData")
ARE_comparison(stations, U1=U_sim_grid, U2=U_xvae_grid, U3=U_gan_grid)
plot(stations)
str(stations)
?!tidyterra::is_regular_grid
?tidyterra::is_regular_grid
tidyterra::is_regular_grid(stations, digits = 6)
ARE_comparison <- function(stations, center=NULL, U1, U2=NULL, U3=NULL, u_vec=NULL, names =c("Truth", "XVAE", "extGAN")){
tidyterra::is_regular_grid(stations, digits = 6) #stop("The spatial input must be on a regular grid.")
if(is.null(center)){
center <- which.min(apply(rdist(stations),1,mean))
}
unit_area <- diff(stations[,1])[1] * diff(stations[,2])[1]
total_area <- unit_area * nrow(stations)
if(is.null(u_vec)) u_vec <- c(seq(0,0.98,0.01),seq(0.9801,0.998,0.0001))
Emp_ARE_ori <- array(NA, c(length(u_vec), 3))
for(iter in 1:length(u_vec)){
u_tmp <- u_vec[iter]
where.exceed <- which(U1[center, ]>u_tmp) ## center of the spatial domain
if(length(where.exceed)>0){
tmp_AE <- rep(NA, length(where.exceed))
for(col in 1:length(where.exceed)){
tmp_AE[col] <- sum(U1[,where.exceed[col]]>u_tmp)*unit_area
}
Emp_ARE_ori[iter,] <- c(mean(tmp_AE), quantile(tmp_AE, p=c(0.025, 0.975)))
}else{
Emp_ARE_ori[iter,] <- c(0,0,total_area)
}
}
Emp_ARE_XVAE <- array(NA, c(length(u_vec), 3))
if(!is.null(U2)){
for(iter in 1:length(u_vec)){
u_tmp <- u_vec[iter]
where.exceed <- which(U2[center, ]>u_tmp) ## center of the spatial domain
if(length(where.exceed)>0){
tmp_AE <- rep(NA, length(where.exceed))
for(col in 1:length(where.exceed)){
tmp_AE[col] <- sum(U2[,where.exceed[col]]>u_tmp)*unit_area
}
Emp_ARE_XVAE[iter,] <- c(mean(tmp_AE), quantile(tmp_AE, p=c(0.025, 0.975)))
}else{
Emp_ARE_XVAE[iter,] <- c(0,0,total_area)
}
}
}
if(!is.null(U2)){
Emp_ARE_extGAN <- array(NA, c(length(u_vec), 3))
for(iter in 1:length(u_vec)){
u_tmp <- u_vec[iter]
where.exceed <- which(U3[center, ]>u_tmp) ## center of the spatial domain
if(length(where.exceed)>0){
tmp_AE <- rep(NA, length(where.exceed))
for(col in 1:length(where.exceed)){
tmp_AE[col] <- sum(U3[,where.exceed[col]]>u_tmp)*unit_area
}
Emp_ARE_extGAN[iter,] <- c(mean(tmp_AE), quantile(tmp_AE, p=c(0.025, 0.975)))
}else{
Emp_ARE_extGAN[iter,] <- c(0,0,total_area)
}
}
}
dat <- data.frame(x = u_vec,
truth = sqrt(Emp_ARE_ori[,1]/pi), truth_lower = sqrt(Emp_ARE_ori[,2]/pi), truth_upper=sqrt(Emp_ARE_ori[,3]/pi),
emu = sqrt(Emp_ARE_XVAE[,1]/pi), emu_lower = sqrt(Emp_ARE_XVAE[,2]/pi), emu_upper=sqrt(Emp_ARE_XVAE[,3]/pi),
gan = sqrt(Emp_ARE_extGAN[,1]/pi), gan_lower = sqrt(Emp_ARE_extGAN[,2]/pi), gan_upper=sqrt(Emp_ARE_extGAN[,3]/pi))
plt <- ggplot(dat,aes(x=x,y=gan)) +
geom_line(aes(color=names[3]),linewidth=1) +
geom_line(aes(y=truth, color=names[1]),linewidth=1) +
geom_line(aes(y=emu, color=names[2]),linewidth=1) +
scale_color_manual(values=c('#0674cf', 'red', 'black')) +
geom_ribbon(data=dat,aes(ymin=gan_lower,ymax=gan_upper),alpha=0.2,fill="#4190d1") +
geom_ribbon(data=dat,aes(ymin=emu_lower,ymax=emu_upper),alpha=0.2,fill="red") +
geom_ribbon(data=dat,aes(ymin=truth_lower,ymax=truth_upper),alpha=0.2,fill="black") +
labs(colour="Type") +
ylab("Average radius of exceedance (ARE)") + xlab("Quantile") +
theme(plot.title = element_text(hjust = 0.5)) +
scale_x_continuous(expand = c(0, 0)) +
scale_y_continuous(expand = c(0, 0), limits=c(0, 13)) +
force_panelsizes(rows = unit(3.05, "in"),
cols = unit(3.05, "in")) + theme(plot.title = element_text(face = 'bold'))
legend <- TRUE; show.axis.y <- TRUE
if(!legend) plt <- plt + guides(color="none")
if(!show.axis.y) plt<- plt + theme( axis.text.y=element_blank(),
axis.ticks.y=element_blank(),
axis.title.y = element_blank())
plt
}
ARE_comparison(stations, U1=U_sim_grid, U2=U_xvae_grid, U3=U_gan_grid)
ARE_comparison <- function(stations, center=NULL, U1, U2=NULL, U3=NULL, u_vec=NULL, names =c("Truth", "XVAE", "extGAN")){
tidyterra::is_regular_grid(stations, digits = 6) #stop("The spatial input must be on a regular grid.")
if(is.null(center)){
center <- which.min(apply(rdist(stations),1,mean))
}
unit_area <- diff(stations[,1])[1] * diff(stations[,2])[1]
total_area <- unit_area * nrow(stations)
if(is.null(u_vec)) u_vec <- c(seq(0,0.98,0.01),seq(0.9801,0.998,0.0001))
Emp_ARE_ori <- array(NA, c(length(u_vec), 3))
for(iter in 1:length(u_vec)){
u_tmp <- u_vec[iter]
where.exceed <- which(U1[center, ]>u_tmp) ## center of the spatial domain
if(length(where.exceed)>0){
tmp_AE <- rep(NA, length(where.exceed))
for(col in 1:length(where.exceed)){
tmp_AE[col] <- sum(U1[,where.exceed[col]]>u_tmp)*unit_area
}
Emp_ARE_ori[iter,] <- c(mean(tmp_AE), quantile(tmp_AE, p=c(0.025, 0.975)))
}else{
Emp_ARE_ori[iter,] <- c(0,0,total_area)
}
}
Emp_ARE_XVAE <- array(NA, c(length(u_vec), 3))
if(!is.null(U2)){
for(iter in 1:length(u_vec)){
u_tmp <- u_vec[iter]
where.exceed <- which(U2[center, ]>u_tmp) ## center of the spatial domain
if(length(where.exceed)>0){
tmp_AE <- rep(NA, length(where.exceed))
for(col in 1:length(where.exceed)){
tmp_AE[col] <- sum(U2[,where.exceed[col]]>u_tmp)*unit_area
}
Emp_ARE_XVAE[iter,] <- c(mean(tmp_AE), quantile(tmp_AE, p=c(0.025, 0.975)))
}else{
Emp_ARE_XVAE[iter,] <- c(0,0,total_area)
}
}
}
if(!is.null(U2)){
Emp_ARE_extGAN <- array(NA, c(length(u_vec), 3))
for(iter in 1:length(u_vec)){
u_tmp <- u_vec[iter]
where.exceed <- which(U3[center, ]>u_tmp) ## center of the spatial domain
if(length(where.exceed)>0){
tmp_AE <- rep(NA, length(where.exceed))
for(col in 1:length(where.exceed)){
tmp_AE[col] <- sum(U3[,where.exceed[col]]>u_tmp)*unit_area
}
Emp_ARE_extGAN[iter,] <- c(mean(tmp_AE), quantile(tmp_AE, p=c(0.025, 0.975)))
}else{
Emp_ARE_extGAN[iter,] <- c(0,0,total_area)
}
}
}
dat <- data.frame(x = u_vec,
truth = sqrt(Emp_ARE_ori[,1]/pi), truth_lower = sqrt(Emp_ARE_ori[,2]/pi), truth_upper=sqrt(Emp_ARE_ori[,3]/pi),
emu = sqrt(Emp_ARE_XVAE[,1]/pi), emu_lower = sqrt(Emp_ARE_XVAE[,2]/pi), emu_upper=sqrt(Emp_ARE_XVAE[,3]/pi),
gan = sqrt(Emp_ARE_extGAN[,1]/pi), gan_lower = sqrt(Emp_ARE_extGAN[,2]/pi), gan_upper=sqrt(Emp_ARE_extGAN[,3]/pi))
plt <- ggplot(dat,aes(x=x,y=gan)) +
geom_line(aes(color=names[3]),linewidth=1) +
geom_line(aes(y=truth, color=names[1]),linewidth=1) +
geom_line(aes(y=emu, color=names[2]),linewidth=1) +
scale_color_manual(values=c('#0674cf', 'red', 'black')) +
geom_ribbon(data=dat,aes(ymin=gan_lower,ymax=gan_upper),alpha=0.2,fill="#4190d1") +
geom_ribbon(data=dat,aes(ymin=emu_lower,ymax=emu_upper),alpha=0.2,fill="red") +
geom_ribbon(data=dat,aes(ymin=truth_lower,ymax=truth_upper),alpha=0.2,fill="black") +
labs(colour="Type") +
ylab("Average radius of exceedance (ARE)") + xlab("Quantile") +
theme(plot.title = element_text(hjust = 0.5)) +
scale_x_continuous(expand = c(0, 0)) +
scale_y_continuous(expand = c(0, 0), limits=c(0, 13)) +
ggh4x::force_panelsizes(rows = unit(3.05, "in"),
cols = unit(3.05, "in")) + theme(plot.title = element_text(face = 'bold'))
legend <- TRUE; show.axis.y <- TRUE
if(!legend) plt <- plt + guides(color="none")
if(!show.axis.y) plt<- plt + theme( axis.text.y=element_blank(),
axis.ticks.y=element_blank(),
axis.title.y = element_blank())
plt
}
ARE_comparison(stations, U1=U_sim_grid, U2=U_xvae_grid, U3=U_gan_grid)
tidyterra::is_regular_grid(stations, digits = 6) #stop("The spatial input must be on a regular grid.")
if(is.null(center)){
center <- which.min(apply(rdist(stations),1,mean))
}
center=NULL
tidyterra::is_regular_grid(stations, digits = 6) #stop("The spatial input must be on a regular grid.")
if(is.null(center)){
center <- which.min(apply(rdist(stations),1,mean))
}
unit_area <- diff(stations[,1])[1] * diff(stations[,2])[1]
total_area <- unit_area * nrow(stations)
total_area
unit_area
diff(stations[,1])[1]
diff(stations[,2])[1]
stations[,2]
diff(unique(stations[,1]))[1] * diff(unique(stations[,2]))[1]
unit_area <- diff(unique(stations[,1]))[1] * diff(unique(stations[,2]))[1]
total_area <- unit_area * nrow(stations)
if(is.null(u_vec)) u_vec <- c(seq(0,0.98,0.01),seq(0.9801,0.998,0.0001))
ARE_comparison <- function(stations, center=NULL, U1, U2=NULL, U3=NULL, u_vec=NULL, names =c("Truth", "XVAE", "extGAN")){
tidyterra::is_regular_grid(stations, digits = 6) #stop("The spatial input must be on a regular grid.")
if(is.null(center)){
center <- which.min(apply(rdist(stations),1,mean))
}
unit_area <- diff(unique(stations[,1]))[1] * diff(unique(stations[,2]))[1]
total_area <- unit_area * nrow(stations)
if(is.null(u_vec)) u_vec <- c(seq(0,0.98,0.01),seq(0.9801,0.998,0.0001))
Emp_ARE_ori <- array(NA, c(length(u_vec), 3))
for(iter in 1:length(u_vec)){
u_tmp <- u_vec[iter]
where.exceed <- which(U1[center, ]>u_tmp) ## center of the spatial domain
if(length(where.exceed)>0){
tmp_AE <- rep(NA, length(where.exceed))
for(col in 1:length(where.exceed)){
tmp_AE[col] <- sum(U1[,where.exceed[col]]>u_tmp)*unit_area
}
Emp_ARE_ori[iter,] <- c(mean(tmp_AE), quantile(tmp_AE, p=c(0.025, 0.975)))
}else{
Emp_ARE_ori[iter,] <- c(0,0,total_area)
}
}
Emp_ARE_XVAE <- array(NA, c(length(u_vec), 3))
if(!is.null(U2)){
for(iter in 1:length(u_vec)){
u_tmp <- u_vec[iter]
where.exceed <- which(U2[center, ]>u_tmp) ## center of the spatial domain
if(length(where.exceed)>0){
tmp_AE <- rep(NA, length(where.exceed))
for(col in 1:length(where.exceed)){
tmp_AE[col] <- sum(U2[,where.exceed[col]]>u_tmp)*unit_area
}
Emp_ARE_XVAE[iter,] <- c(mean(tmp_AE), quantile(tmp_AE, p=c(0.025, 0.975)))
}else{
Emp_ARE_XVAE[iter,] <- c(0,0,total_area)
}
}
}
if(!is.null(U2)){
Emp_ARE_extGAN <- array(NA, c(length(u_vec), 3))
for(iter in 1:length(u_vec)){
u_tmp <- u_vec[iter]
where.exceed <- which(U3[center, ]>u_tmp) ## center of the spatial domain
if(length(where.exceed)>0){
tmp_AE <- rep(NA, length(where.exceed))
for(col in 1:length(where.exceed)){
tmp_AE[col] <- sum(U3[,where.exceed[col]]>u_tmp)*unit_area
}
Emp_ARE_extGAN[iter,] <- c(mean(tmp_AE), quantile(tmp_AE, p=c(0.025, 0.975)))
}else{
Emp_ARE_extGAN[iter,] <- c(0,0,total_area)
}
}
}
dat <- data.frame(x = u_vec,
truth = sqrt(Emp_ARE_ori[,1]/pi), truth_lower = sqrt(Emp_ARE_ori[,2]/pi), truth_upper=sqrt(Emp_ARE_ori[,3]/pi),
emu = sqrt(Emp_ARE_XVAE[,1]/pi), emu_lower = sqrt(Emp_ARE_XVAE[,2]/pi), emu_upper=sqrt(Emp_ARE_XVAE[,3]/pi),
gan = sqrt(Emp_ARE_extGAN[,1]/pi), gan_lower = sqrt(Emp_ARE_extGAN[,2]/pi), gan_upper=sqrt(Emp_ARE_extGAN[,3]/pi))
plt <- ggplot(dat,aes(x=x,y=gan)) +
geom_line(aes(color=names[3]),linewidth=1) +
geom_line(aes(y=truth, color=names[1]),linewidth=1) +
geom_line(aes(y=emu, color=names[2]),linewidth=1) +
scale_color_manual(values=c('#0674cf', 'red', 'black')) +
geom_ribbon(data=dat,aes(ymin=gan_lower,ymax=gan_upper),alpha=0.2,fill="#4190d1") +
geom_ribbon(data=dat,aes(ymin=emu_lower,ymax=emu_upper),alpha=0.2,fill="red") +
geom_ribbon(data=dat,aes(ymin=truth_lower,ymax=truth_upper),alpha=0.2,fill="black") +
labs(colour="Type") +
ylab("Average radius of exceedance (ARE)") + xlab("Quantile") +
theme(plot.title = element_text(hjust = 0.5)) +
scale_x_continuous(expand = c(0, 0)) +
scale_y_continuous(expand = c(0, 0), limits=c(0, 13)) +
ggh4x::force_panelsizes(rows = unit(3.05, "in"),
cols = unit(3.05, "in")) + theme(plot.title = element_text(face = 'bold'))
legend <- TRUE; show.axis.y <- TRUE
if(!legend) plt <- plt + guides(color="none")
if(!show.axis.y) plt<- plt + theme( axis.text.y=element_blank(),
axis.ticks.y=element_blank(),
axis.title.y = element_blank())
plt
}
ARE_comparison(stations, U1=U_sim_grid, U2=U_xvae_grid, U3=U_gan_grid)
ARE_comparison <- function(stations, center=NULL, U1, U2=NULL, U3=NULL, u_vec=NULL, names =c("Truth", "XVAE", "extGAN")){
tidyterra::is_regular_grid(stations, digits = 6) #stop("The spatial input must be on a regular grid.")
if(is.null(center)){
center <- which.min(apply(rdist(stations),1,mean))
}
unit_area <- diff(unique(stations[,1]))[1] * diff(unique(stations[,2]))[1]
total_area <- unit_area * nrow(stations)
if(is.null(u_vec)) u_vec <- c(seq(0,0.98,0.01),seq(0.9801,0.998,0.0001))
Emp_ARE_ori <- array(NA, c(length(u_vec), 3))
for(iter in 1:length(u_vec)){
u_tmp <- u_vec[iter]
where.exceed <- which(U1[center, ]>u_tmp) ## center of the spatial domain
if(length(where.exceed)>0){
tmp_AE <- rep(NA, length(where.exceed))
for(col in 1:length(where.exceed)){
tmp_AE[col] <- sum(U1[,where.exceed[col]]>u_tmp)*unit_area
}
Emp_ARE_ori[iter,] <- c(mean(tmp_AE), quantile(tmp_AE, p=c(0.05, 0.95)))
}else{
Emp_ARE_ori[iter,] <- c(0,0,total_area)
}
}
Emp_ARE_XVAE <- array(NA, c(length(u_vec), 3))
if(!is.null(U2)){
for(iter in 1:length(u_vec)){
u_tmp <- u_vec[iter]
where.exceed <- which(U2[center, ]>u_tmp) ## center of the spatial domain
if(length(where.exceed)>0){
tmp_AE <- rep(NA, length(where.exceed))
for(col in 1:length(where.exceed)){
tmp_AE[col] <- sum(U2[,where.exceed[col]]>u_tmp)*unit_area
}
Emp_ARE_XVAE[iter,] <- c(mean(tmp_AE), quantile(tmp_AE, p=c(0.05, 0.95)))
}else{
Emp_ARE_XVAE[iter,] <- c(0,0,total_area)
}
}
}
if(!is.null(U2)){
Emp_ARE_extGAN <- array(NA, c(length(u_vec), 3))
for(iter in 1:length(u_vec)){
u_tmp <- u_vec[iter]
where.exceed <- which(U3[center, ]>u_tmp) ## center of the spatial domain
if(length(where.exceed)>0){
tmp_AE <- rep(NA, length(where.exceed))
for(col in 1:length(where.exceed)){
tmp_AE[col] <- sum(U3[,where.exceed[col]]>u_tmp)*unit_area
}
Emp_ARE_extGAN[iter,] <- c(mean(tmp_AE), quantile(tmp_AE, p=c(0.05, 0.95)))
}else{
Emp_ARE_extGAN[iter,] <- c(0,0,total_area)
}
}
}
dat <- data.frame(x = u_vec,
truth = sqrt(Emp_ARE_ori[,1]/pi), truth_lower = sqrt(Emp_ARE_ori[,2]/pi), truth_upper=sqrt(Emp_ARE_ori[,3]/pi),
emu = sqrt(Emp_ARE_XVAE[,1]/pi), emu_lower = sqrt(Emp_ARE_XVAE[,2]/pi), emu_upper=sqrt(Emp_ARE_XVAE[,3]/pi),
gan = sqrt(Emp_ARE_extGAN[,1]/pi), gan_lower = sqrt(Emp_ARE_extGAN[,2]/pi), gan_upper=sqrt(Emp_ARE_extGAN[,3]/pi))
plt <- ggplot(dat,aes(x=x,y=gan)) +
geom_line(aes(color=names[3]),linewidth=1) +
geom_line(aes(y=truth, color=names[1]),linewidth=1) +
geom_line(aes(y=emu, color=names[2]),linewidth=1) +
scale_color_manual(values=c('#0674cf', 'red', 'black')) +
geom_ribbon(data=dat,aes(ymin=gan_lower,ymax=gan_upper),alpha=0.2,fill="#4190d1") +
geom_ribbon(data=dat,aes(ymin=emu_lower,ymax=emu_upper),alpha=0.2,fill="red") +
geom_ribbon(data=dat,aes(ymin=truth_lower,ymax=truth_upper),alpha=0.2,fill="black") +
labs(colour="Type") +
ylab("Average radius of exceedance (ARE)") + xlab("Quantile") +
theme(plot.title = element_text(hjust = 0.5)) +
scale_x_continuous(expand = c(0, 0)) +
scale_y_continuous(expand = c(0, 0), limits=c(0, 13)) +
ggh4x::force_panelsizes(rows = unit(3.05, "in"),
cols = unit(3.05, "in")) + theme(plot.title = element_text(face = 'bold'))
legend <- TRUE; show.axis.y <- TRUE
if(!legend) plt <- plt + guides(color="none")
if(!show.axis.y) plt<- plt + theme( axis.text.y=element_blank(),
axis.ticks.y=element_blank(),
axis.title.y = element_blank())
plt
}
ARE_comparison(stations, U1=U_sim_grid, U2=U_xvae_grid, U3=U_gan_grid)
ARE_comparison <- function(stations, center=NULL, U1, U2=NULL, U3=NULL, u_vec=NULL, names =c("Truth", "XVAE", "extGAN")){
tidyterra::is_regular_grid(stations, digits = 6) #stop("The spatial input must be on a regular grid.")
if(is.null(center)){
center <- which.min(apply(rdist(stations),1,mean))
}
unit_area <- diff(unique(stations[,1]))[1] * diff(unique(stations[,2]))[1]
total_area <- unit_area * nrow(stations)
if(is.null(u_vec)) u_vec <- c(seq(0,0.98,0.01),seq(0.9801,0.998,0.0001))
Emp_ARE_ori <- array(NA, c(length(u_vec), 3))
for(iter in 1:length(u_vec)){
u_tmp <- u_vec[iter]
where.exceed <- which(U1[center, ]>u_tmp) ## center of the spatial domain
if(length(where.exceed)>0){
tmp_AE <- rep(NA, length(where.exceed))
for(col in 1:length(where.exceed)){
tmp_AE[col] <- sum(U1[,where.exceed[col]]>u_tmp)*unit_area
}
Emp_ARE_ori[iter,] <- c(mean(tmp_AE), quantile(tmp_AE, p=c(0.025, 0.975)))
}else{
Emp_ARE_ori[iter,] <- c(0,0,total_area)
}
}
Emp_ARE_XVAE <- array(NA, c(length(u_vec), 3))
if(!is.null(U2)){
for(iter in 1:length(u_vec)){
u_tmp <- u_vec[iter]
where.exceed <- which(U2[center, ]>u_tmp) ## center of the spatial domain
if(length(where.exceed)>0){
tmp_AE <- rep(NA, length(where.exceed))
for(col in 1:length(where.exceed)){
tmp_AE[col] <- sum(U2[,where.exceed[col]]>u_tmp)*unit_area
}
Emp_ARE_XVAE[iter,] <- c(mean(tmp_AE), quantile(tmp_AE, p=c(0.025, 0.975)))
}else{
Emp_ARE_XVAE[iter,] <- c(0,0,total_area)
}
}
}
if(!is.null(U2)){
Emp_ARE_extGAN <- array(NA, c(length(u_vec), 3))
for(iter in 1:length(u_vec)){
u_tmp <- u_vec[iter]
where.exceed <- which(U3[center, ]>u_tmp) ## center of the spatial domain
if(length(where.exceed)>0){
tmp_AE <- rep(NA, length(where.exceed))
for(col in 1:length(where.exceed)){
tmp_AE[col] <- sum(U3[,where.exceed[col]]>u_tmp)*unit_area
}
Emp_ARE_extGAN[iter,] <- c(mean(tmp_AE), quantile(tmp_AE, p=c(0.025, 0.975)))
}else{
Emp_ARE_extGAN[iter,] <- c(0,0,total_area)
}
}
}
# dat <- data.frame(x = u_vec,
#                   truth = sqrt(Emp_ARE_ori[,1]/pi), truth_lower = sqrt(Emp_ARE_ori[,2]/pi), truth_upper=sqrt(Emp_ARE_ori[,3]/pi),
#                   emu = sqrt(Emp_ARE_XVAE[,1]/pi), emu_lower = sqrt(Emp_ARE_XVAE[,2]/pi), emu_upper=sqrt(Emp_ARE_XVAE[,3]/pi),
#                   gan = sqrt(Emp_ARE_extGAN[,1]/pi), gan_lower = sqrt(Emp_ARE_extGAN[,2]/pi), gan_upper=sqrt(Emp_ARE_extGAN[,3]/pi))
dat <- data.frame(x = u_vec, truth = sqrt(Emp_ARE_ori[,1]/pi), truth_lower = sqrt(Emp_ARE_ori[,1]/pi)+(sqrt(Emp_ARE_ori[,2]/pi)-sqrt(Emp_ARE_ori[,1]/pi))/2,
truth_upper=sqrt(Emp_ARE_ori[,1]/pi)+(sqrt(Emp_ARE_ori[,3]/pi)-sqrt(Emp_ARE_ori[,1]/pi))/2, emu = sqrt(Emp_ARE_XVAE[,1]/pi),
emu_lower = sqrt(Emp_ARE_XVAE[,1]/pi)+(sqrt(Emp_ARE_XVAE[,2]/pi)-sqrt(Emp_ARE_XVAE[,1]/pi))/2,
emu_upper=sqrt(Emp_ARE_XVAE[,1]/pi)+(sqrt(Emp_ARE_XVAE[,3]/pi)-sqrt(Emp_ARE_XVAE[,1]/pi))/2,
gan = sqrt(Emp_ARE_extGAN[,1]/pi),
gan_lower = sqrt(Emp_ARE_extGAN[,1]/pi)+(sqrt(Emp_ARE_extGAN[,2]/pi)-sqrt(Emp_ARE_extGAN[,1]/pi))/2,
gan_upper=sqrt(Emp_ARE_extGAN[,1]/pi)+(sqrt(Emp_ARE_extGAN[,3]/pi)-sqrt(Emp_ARE_extGAN[,1]/pi))/2)
plt <- ggplot(dat,aes(x=x,y=gan)) +
geom_line(aes(color=names[3]),linewidth=1) +
geom_line(aes(y=truth, color=names[1]),linewidth=1) +
geom_line(aes(y=emu, color=names[2]),linewidth=1) +
scale_color_manual(values=c('#0674cf', 'red', 'black')) +
geom_ribbon(data=dat,aes(ymin=gan_lower,ymax=gan_upper),alpha=0.2,fill="#4190d1") +
geom_ribbon(data=dat,aes(ymin=emu_lower,ymax=emu_upper),alpha=0.2,fill="red") +
geom_ribbon(data=dat,aes(ymin=truth_lower,ymax=truth_upper),alpha=0.2,fill="black") +
labs(colour="Type") +
ylab("Average radius of exceedance (ARE)") + xlab("Quantile") +
theme(plot.title = element_text(hjust = 0.5)) +
scale_x_continuous(expand = c(0, 0)) +
scale_y_continuous(expand = c(0, 0), limits=c(0, 13)) +
ggh4x::force_panelsizes(rows = unit(3.05, "in"),
cols = unit(3.05, "in")) + theme(plot.title = element_text(face = 'bold'))
legend <- TRUE; show.axis.y <- TRUE
if(!legend) plt <- plt + guides(color="none")
if(!show.axis.y) plt<- plt + theme( axis.text.y=element_blank(),
axis.ticks.y=element_blank(),
axis.title.y = element_blank())
plt
}
ARE_comparison(stations, U1=U_sim_grid, U2=U_xvae_grid, U3=U_gan_grid)
install.packages("roxygen2")
roxygen2::roxygenize()
roxygen2::roxygenize()
devtools::build()
install.packages("devtools")
devtools::build()
devtools::install()
install.packages("stabledist")
devtools::install()
install.packages("FMStable")
devtools::install()
library(XVAE)
?ARE_comparison
devtools::build()
devtools::install()
?emulate_from_trained_XVAE
library(XVAE)
source("~/Desktop/GEV-GP_VAE/XVAE/R/XVAE_utils.R")
source("XVAE_utils.R")
load("./data/example_X.RData")
knots <- data_driven_knots(X, stations, 0.95, echo=TRUE)
r <- calc_radius(knots, stations)
eucD <- rdist(stations,as.matrix(knots))
W <- wendland(eucD,r=r)
W <- sweep(W, 1, rowSums(W), FUN="/")
dim(W)  # Verify dimensions: `n.s` × `k`
k = nrow(knots)
n.s <- nrow(stations)
n.t <- ncol(X)
stations <- data.frame(stations)
knots <- data.frame(knots)
visualize_knots(knots, stations, r, W)
# Setting up the Fréchet white noise process
alpha = 0.5; tau <- 0.1; m <- 0.85
W_alpha <- W^(1/alpha)
Z_approx <- array(NA, dim=c(k, n.t))
for (iter in 1:n.t){
if(iter %% 10 == 0 ) cat('Finding good initial Z_t for time', iter, '\n')
Z_approx[,iter] <- relu(qr.solve(a=W_alpha, b=X[,iter]))
}
# Compute approximations
Y_star <- (W_alpha)%*%(Z_approx)
Y_approx <- Y_star - relu(Y_star-X)
source("Initializing_XVAE.R")
source("XVAE_initialization.R")
learning_rate <- -1e-15; alpha_v <- 0.9
lrelu <- nn_leaky_relu(-0.01)
nEpoch = 10000
learning_rate <- -1e-15; alpha_v <- 0.9
lrelu <- nn_leaky_relu(-0.01)
nEpoch = 100
XVAE_training_loop()
